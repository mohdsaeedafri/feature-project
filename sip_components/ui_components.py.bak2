"""
UIComponents - Standardized UI elements for the Store Intelligence Platform
Includes data tables, metric cards, charts, and download buttons
"""
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import calendar
import math
import logging
from st_aggrid import AgGrid
from st_aggrid.grid_options_builder import GridOptionsBuilder

class UIComponents:
    @staticmethod
    def render_metric_card(title, value, subtitle="", column=None):
        """Render a standardized metric card"""
        # Handle different value types (numbers vs strings)
        if isinstance(value, (int, float)):
            formatted_value = f"{value:,}"
        else:
            formatted_value = str(value)
            
        if column:
            with column:
                st.markdown(f"""
                <h1 style='font-size: 40px; text-align: left; margin-bottom: 0px;'>{formatted_value}</h1>
                <h6 style='text-align: left; margin-top: 0px;'>{title}</h6>
                """, unsafe_allow_html=True)
        else:
            st.markdown(f"""
            <h1 style='font-size: 40px; text-align: left; margin-bottom: 0px;'>{formatted_value}</h1>
            <h6 style='text-align: left; margin-top: 0px;'>{title}</h6>
            """, unsafe_allow_html=True)
            
    @staticmethod
    def render_horizontal_line():
        """Render a standardized horizontal line"""
        st.markdown("""<style>.custom-hr {border: none;border-top: 1px solid #808080; width: 100%; margin: -10px; padding: 0; margin-left: auto; margin-right: auto;
        }
        </style>
        """,
        unsafe_allow_html=True
        )
        st.markdown('<hr class="custom-hr">', unsafe_allow_html=True)
        
    @staticmethod
    def calculate_yaxis_limit(value):
        """Calculate the next highest rounded limit for y-axis"""
        try:
            if pd.isna(value):
                logging.warning("No data available to display the chart.")
                return None
            if value <= 10:
                return 10
            increased_value = value + (value * 0.1)
            return math.ceil(increased_value / 10) * 10
        except ValueError:
            return None
            
    @staticmethod
    def render_active_stores_over_time_chart(data, column=None):
        """Render the active stores over time chart"""
        try:
            data['PeriodMonth'] = data['Period'].dt.to_period('M').dt.to_timestamp()
            active_stores_over_time = data.groupby('PeriodMonth').size().reset_index(name='ActiveCount')
            active_stores_over_time.rename(columns={'PeriodMonth': 'MonthStart'}, inplace=True)

            # Create lists to store metadata for each data point
            num_sectors_list = []
            num_banners_list = []
            num_states_list = []
            num_msa_list = []

            # Calculate metadata for each month
            for month in active_stores_over_time['MonthStart']:
                month_data = data[data['PeriodMonth'] == month]
                num_sectors_list.append(month_data['Sector_Coresight'].nunique())
                num_banners_list.append(month_data['ChainName_Coresight'].nunique())
                num_states_list.append(month_data['State'].nunique())
                num_msa_list.append(month_data['MsaName'].nunique())

            # Create the figure with visible counts
            fig_active_line = go.Figure()

            # Add trace with both permanent labels and hover info
            fig_active_line.add_trace(go.Scatter(
                x=active_stores_over_time['MonthStart'],
                y=active_stores_over_time['ActiveCount'],
                name='Active Stores',
                mode='lines+markers+text',
                text=[f"{x:,}" for x in active_stores_over_time['ActiveCount']],
                textposition='top center',
                line=dict(color='#CBCACA', width=2),
                marker=dict(size=7, color='#CBCACA'),
                hovertemplate=(
                    "%{x|%b %Y}<br>"
                    "<span style='color:#CBCACA'>●</span> "
                    "<b>Active Store Count:</b> <b>%{y:,}</b><br><br>"
                    "<span style='color:#CBCACA'>•</span> "
                    "<span style='color:black'>Number of Sectors: %{customdata[0]}</span><br>"
                    "<span style='color:#CBCACA'>•</span> "
                    "<span style='color:black'>Number of Banners: %{customdata[1]}</span><br>"
                    "<span style='color:#CBCACA'>•</span> "
                    "<span style='color:black'>Number of States: %{customdata[2]}</span><br>"
                    "<span style='color:#CBCACA'>•</span> "
                    "<span style='color:black'>Number of MSA: %{customdata[3]}</span><br>"
                    "<extra></extra>"
                ),
                customdata=list(zip(num_sectors_list, num_banners_list, num_states_list, num_msa_list)),
                hoverlabel=dict(
                    bgcolor="white",
                    bordercolor="#CBCACA",
                    font=dict(size=13, color="black", family="Arial")
                )
            ))

            # Update layout with text styling
            fig_active_line.update_layout(
                yaxis_title="Active Stores",
                margin=dict(l=10, r=10, t=60, b=40),
                height=400,
                xaxis=dict(
                    showline=True,
                    zeroline=False,
                    title="",
                    tickformat="%b %Y"
                ),
                yaxis=dict(
                    showline=True,
                    zeroline=False,
                    automargin=True
                ),
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                ),
                uniformtext_minsize=8,
                uniformtext_mode='hide'
            )

            # Same config as before
            config = {
                'displayModeBar': True,
                'displaylogo': False,
                'toImageButtonOptions': {
                    'format': 'png',
                    'filename': 'active_stores_over_time',
                    'height': 400,
                    'width': 700,
                    'scale': 1
                }
            }

            # Display the chart
            if column:
                with column:
                    st.markdown("<h4 style='font-size: 20px;text-align: center;'>Active Stores Over Time</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_active_line, use_container_width=True, config=config)
            else:
                st.markdown("<h4 style='font-size: 20px;text-align: center;'>Active Stores Over Time</h4>", unsafe_allow_html=True)
                st.plotly_chart(fig_active_line, use_container_width=True, config=config)
                
        except Exception as e:
            st.write(f"Error creating chart: {e}")
            
    @staticmethod
    def render_active_chains_bar_chart(data, column=None):
        """Render the active chains bar chart (Recent Month Only)"""
        try:
            # Get the most recent period from the filtered data
            recent_period = data['Period'].max()

            # Filter for only the most recent period's data
            recent_active_data = data[data['Period'] == recent_period]

            # Count stores by chain for the recent period only
            active_store_counts = recent_active_data['ChainName_Coresight'].value_counts().head(15)

            if not active_store_counts.empty:
                y_max_active = UIComponents.calculate_yaxis_limit(active_store_counts.max())

                # Calculate metadata for the recent period
                recent_period_str = recent_period.strftime('%b %Y')
                num_states = recent_active_data['State'].nunique()
                num_msa = recent_active_data['MsaName'].nunique()

                # Create figure with consistent styling
                fig_active_bar = go.Figure()

                fig_active_bar.add_trace(go.Bar(
                    x=active_store_counts.index,
                    y=active_store_counts.values,
                    marker_color='#CBCACA',  # Using your specified gray color
                    text=[f"{x:,}" for x in active_store_counts.values],  # Formatted with thousands separator
                    textposition='outside',
                    hovertemplate=(
                        "<b>%{x}</b><br>"  # Banner name
                        "<span style='color:#CBCACA'>●</span> "
                        "<b>Active Stores:</b> %{y:,}<br><br>"
                        "<span style='color:#CBCACA'>•</span> "
                        f"<span style='color:black'>Date Period: {recent_period_str}</span><br>"
                        "<span style='color:#CBCACA'>•</span> "
                        f"<span style='color:black'>Number of States: {num_states:,}</span><br>"
                        "<span style='color:#CBCACA'>•</span> "
                        f"<span style='color:black'>Number of MSA: {num_msa:,}</span><br>"
                        "<extra></extra>"
                    ),
                    hoverlabel=dict(
                        bgcolor="white",
                        bordercolor='#CBCACA',
                        font=dict(size=13, color="black", family="Arial")
                    )
                ))

                # Update layout
                fig_active_bar.update_layout(
                    yaxis_title="Active Stores",
                    margin=dict(l=10, r=10, t=40, b=40),
                    height=400,
                    xaxis=dict(
                        showline=True,
                        zeroline=False,
                        title=""
                    ),
                    yaxis=dict(
                        showline=True,
                        zeroline=False,
                        range=[0, y_max_active] if y_max_active else None
                    ),
                    uniformtext_minsize=8,
                    uniformtext_mode='hide'
                )

                config = {
                    'displayModeBar': True,
                    'displaylogo': False,
                    'toImageButtonOptions': {
                        'format': 'png',
                        'filename': 'top_15_active_chains',
                        'height': 400,
                        'width': 700,
                        'scale': 1
                    }
                }

                if column:
                    with column:
                        st.markdown("<h4 style='font-size: 20px; text-align: center;'>Top 15 Active Chains</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_active_bar, use_container_width=True, config=config)
                else:
                    st.markdown("<h4 style='font-size: 20px; text-align: center;'>Top 15 Active Chains</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_active_bar, use_container_width=True, config=config)
            else:
                if column:
                    with column:
                        st.write("No data available for the selected filters.")
                else:
                    st.write("No data available for the selected filters.")
        except Exception as e:
            st.write(f"Error creating chart: {e}")
            
    @staticmethod
    def render_opened_stores_over_time_chart(data, column=None, store_type="Opened", color="#A3C0CE", store_label="Store Opened Count"):
        """Render the opened stores over time chart"""
        try:
            data['PeriodMonth'] = data['Period'].dt.to_period('M').dt.to_timestamp()
            opened_stores_over_time = data.groupby('PeriodMonth').size().reset_index(name='OpenedCount')
            opened_stores_over_time.rename(columns={'PeriodMonth': 'MonthStart'}, inplace=True)

            # Create lists to store metadata for each data point
            num_sectors_list = []
            num_banners_list = []
            num_states_list = []
            num_msa_list = []

            # Calculate metadata for each month
            for month in opened_stores_over_time['MonthStart']:
                month_data = data[data['PeriodMonth'] == month]
                num_sectors_list.append(month_data['Sector_Coresight'].nunique())
                num_banners_list.append(month_data['ChainName_Coresight'].nunique())
                num_states_list.append(month_data['State'].nunique())
                num_msa_list.append(month_data['MsaName'].nunique())

            # Create the figure with visible counts
            fig_opened_line = go.Figure()

            # Add trace with both permanent labels and hover info
            fig_opened_line.add_trace(go.Scatter(
                x=opened_stores_over_time['MonthStart'],
                y=opened_stores_over_time['OpenedCount'],
                name=f'{store_type} Stores',
                mode='lines+markers+text',
                text=[f"{x:,}" for x in opened_stores_over_time['OpenedCount']],
                textposition='top center',
                line=dict(color=color, width=2),
                marker=dict(size=7),
                hovertemplate=(
                    "%{x|%b %Y}<br>"
                    f"<span style='color:{color}'>●</span> "
                    f"<b>{store_label}:</b> <b>%{{y:,}}</b><br><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of Sectors: %{customdata[0]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of Banners: %{customdata[1]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of States: %{customdata[2]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of MSA: %{customdata[3]}</span><br>"
                    "<extra></extra>"
                ),
                customdata=list(zip(num_sectors_list, num_banners_list, num_states_list, num_msa_list)),
                hoverlabel=dict(
                    bgcolor="white",
                    bordercolor=color,
                    font=dict(size=13, color="black", family="Arial")
                )
            ))

            # Update layout with text styling
            fig_opened_line.update_layout(
                yaxis_title=f"{store_type} Stores",
                margin=dict(l=10, r=10, t=60, b=40),
                height=400,
                xaxis=dict(
                    showline=True,
                    zeroline=False,
                    title="",
                    tickformat="%b %Y"
                ),
                yaxis=dict(
                    showline=True,
                    zeroline=False,
                    automargin=True
                ),
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                ),
                uniformtext_minsize=8,
                uniformtext_mode='hide'
            )

            config = {
                'displayModeBar': True,
                'displaylogo': False,
                'toImageButtonOptions': {
                    'format': 'png',
                    'filename': 'opened_stores_over_time',
                    'height': 400,
                    'width': 700,
                    'scale': 1
                }
            }

            if column:
                with column:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores Over Time</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_line, use_container_width=True, config=config)
            else:
                st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores Over Time</h4>", unsafe_allow_html=True)
                st.plotly_chart(fig_opened_line, use_container_width=True, config=config)
                
        except Exception as e:
            st.write(f"Error creating chart: {e}")
            
    @staticmethod
    def render_opened_chains_bar_chart(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened chains bar chart"""
        try:
            opened_store_counts = data['ChainName_Coresight'].value_counts().head(15)
            
            if not opened_store_counts.empty:
                y_max_opened = UIComponents.calculate_yaxis_limit(opened_store_counts.max())

                # Calculate dynamic date period
                start_date = data['Period'].min()
                end_date = data['Period'].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str = end_date.strftime("%b %Y")
                date_period = f"{start_date_str} to {end_date_str}"

                # Calculate metadata for the entire dataset
                num_states = data['State'].nunique()
                num_msa = data['MsaName'].nunique()

                # Create figure with consistent styling
                fig_opened_bar = go.Figure()

                fig_opened_bar.add_trace(go.Bar(
                    x=opened_store_counts.index,
                    y=opened_store_counts.values,
                    marker_color=color,
                    text=[f"{x:,}" for x in opened_store_counts.values],
                    textposition='outside',
                    hovertemplate=(
                        "<b>%{x}</b><br>"
                        f"<span style='color:{color}'>●</span> "
                        f"<b>{store_type} Stores:</b> %{{y:,}}<br><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Date Period: {date_period}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Number of States: {num_states:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Number of MSA: {num_msa:,}</span><br>"
                        "<extra></extra>"
                    ),
                    hoverlabel=dict(
                        bgcolor="white",
                        bordercolor=color,
                        font=dict(size=13, color="black", family="Arial")
                    )
                ))

                # Calculate dynamic height based on number of banners
                dynamic_height = 400 + (20 * (len(opened_store_counts) - 10)) if len(opened_store_counts) > 10 else 400

                fig_opened_bar.update_layout(
                    xaxis_title="Banner Name",
                    yaxis_title=f"{store_type} Stores",
                    yaxis=dict(
                        range=[0, y_max_opened],
                        autorange=False,
                        showline=True,
                        zeroline=False
                    ),
                    xaxis=dict(
                        showline=True,
                        zeroline=False,
                        tickangle=45 if len(opened_store_counts) > 5 else 0,
                        tickfont=dict(size=11)
                    ),
                    height=dynamic_height,
                    margin=dict(l=20, r=20, t=60, b=40 + (10 * len(opened_store_counts))),
                    uniformtext_minsize=8,
                    uniformtext_mode='hide'
                )

                # Adjust for many banners
                if len(opened_store_counts) > 8:
                    fig_opened_bar.update_layout(
                        xaxis=dict(tickangle=60),
                        margin=dict(b=60 + (10 * len(opened_store_counts)))
                    )

                config = {
                    'displayModeBar': True,
                    'displaylogo': False,
                    'toImageButtonOptions': {
                        'format': 'png',
                        'filename': 'opened_chains_bar_chart',
                        'height': dynamic_height,
                        'width': 700,
                        'scale': 1
                    }
                }

                if column:
                    with column:
                        num_banners = min(15, opened_store_counts.shape[0])
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {num_banners} Banners</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_bar, use_container_width=True, config=config)
                else:
                    num_banners = min(15, opened_store_counts.shape[0])
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {num_banners} Banners</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_bar, use_container_width=True, config=config)
            else:
                if column:
                    with column:
                        st.write("No data available for the selected filters.")
                else:
                    st.write("No data available for the selected filters.")
        except Exception as e:
            st.write(f"Error creating chart: {e}")
            
    @staticmethod
    def render_opened_stores_by_state_map(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened stores by state map"""
        try:
            # For Net data, calculate net openings (opened - closed)
            if store_type == "Net" and 'data_from' in data.columns:
                # Group by State and data_from to get counts for each
                state_data = data.groupby(['State', 'data_from']).agg(
                    Count=('State', 'size'),
                    Population=('Population', 'max')
                ).reset_index()
                
                # Pivot to get opened and closed counts as separate columns
                state_pivot = state_data.pivot_table(index='State', columns='data_from', values='Count', aggfunc='first').fillna(0)
                
                # Calculate net openings
                opened_counts = state_pivot.get('opened', pd.Series(0, index=state_pivot.index))
                closed_counts = state_pivot.get('closed', pd.Series(0, index=state_pivot.index))
                net_counts = opened_counts - closed_counts
                
                # Create DataFrame with net counts
                opened_by_state = pd.DataFrame({
                    'State': net_counts.index,
                    'Opened Stores': net_counts.values
                })
                # Remove rows with zero net counts
                opened_by_state = opened_by_state[opened_by_state['Opened Stores'] != 0]
            else:
                # Dictionary to convert full state names to two-letter abbreviations
                state_abbreviations = {
                    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR',
                    'California': 'CA', 'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE',
                    'District of Columbia': 'DC', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI',
                    'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS',
                    'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
                    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
                    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV',
                    'New Hampshire': 'NH', 'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY',
                    'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
                    'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
                    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
                    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV',
                    'Wisconsin': 'WI', 'Wyoming': 'WY', 'Puerto Rico': 'PR'
                }

                # Function to map full state names to abbreviations
                def map_state_names(df, state_col='State'):
                    df[state_col] = df[state_col].map(lambda x: state_abbreviations.get(x, x))
                    return df

                # Apply the mapping
                mapped_data = map_state_names(data.copy())

                # Group opened data by state
                opened_by_state = mapped_data.groupby('State').size().reset_index(name='Opened Stores')
                opened_by_state = opened_by_state.dropna()  # Drop any rows with unmapped states

            if opened_by_state.empty or opened_by_state['State'].isna().all():
                if column:
                    with column:
                        st.write("No state data available for map display.")
                else:
                    st.write("No state data available for map display.")
            else:
                import math

                def calculate_distance(lat1, lon1, lat2, lon2):
                    """Calculate distance between two points on map"""
                    return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)

                def detect_overlapping_states_by_count(opened_by_state, state_centers, min_distance=1.5):
                    """
                    Detect states that are too close to each other and would cause overlapping text
                    Returns a list of states to exclude from annotations
                    """
                    states_to_exclude = set()
                    
                    # Known problematic clusters in the Northeast and small states
                    northeast_clusters = [
                        ['CT', 'RI', 'MA'],  # Connecticut, Rhode Island, Massachusetts cluster
                        ['VT', 'NH', 'ME'],  # Vermont, New Hampshire, Maine cluster
                        ['NJ', 'DE', 'MD'],  # New Jersey, Delaware, Maryland cluster
                    ]
                    
                    # Additional states to always exclude (small or problematic positioning)
                    always_exclude = ['ME', 'MA', 'DC', 'WV']
                    
                    # Add always excluded states
                    for state in always_exclude:
                        if state in opened_by_state['State'].values:
                            states_to_exclude.add(state)
                    
                    # Check each cluster and keep only the state with highest value
                    for cluster in northeast_clusters:
                        cluster_states = [state for state in cluster if state in opened_by_state['State'].values]
                        if len(cluster_states) > 1:
                            # Find the state with highest store count in this cluster
                            cluster_data = opened_by_state[opened_by_state['State'].isin(cluster_states)]
                            max_state = cluster_data.loc[cluster_data['Opened Stores'].idxmax(), 'State']
                            
                            # Exclude all others in the cluster
                            for state in cluster_states:
                                if state != max_state:
                                    states_to_exclude.add(state)
                    
                    # Additional proximity check for any remaining states
                    remaining_states = [state for state in opened_by_state['State'] if state not in states_to_exclude]
                    
                    for i, state1 in enumerate(remaining_states):
                        if state1 in states_to_exclude:
                            continue
                            
                        for state2 in remaining_states[i+1:]:
                            if state2 in states_to_exclude:
                                continue
                                
                            if state1 in state_centers and state2 in state_centers:
                                distance = calculate_distance(
                                    state_centers[state1][1], state_centers[state1][0],
                                    state_centers[state2][1], state_centers[state2][0]
                                )
                                
                                if distance < min_distance:
                                    # Keep the state with higher store count
                                    state1_value = opened_by_state[opened_by_state['State'] == state1]['Opened Stores'].iloc[0]
                                    state2_value = opened_by_state[opened_by_state['State'] == state2]['Opened Stores'].iloc[0]
                                    
                                    if state1_value < state2_value:
                                        states_to_exclude.add(state1)
                                    else:
                                        states_to_exclude.add(state2)
                    
                    return list(states_to_exclude)

                # Dictionary to convert full state names to two-letter abbreviations
                state_abbreviations = {
                    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR',
                    'California': 'CA', 'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE',
                    'District of Columbia': 'DC', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI',
                    'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS',
                    'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
                    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
                    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV',
                    'New Hampshire': 'NH', 'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY',
                    'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
                    'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
                    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
                    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV',
                    'Wisconsin': 'WI', 'Wyoming': 'WY', 'Puerto Rico': 'PR'
                }

                # Create reverse dictionary to convert abbreviations to full names
                abbreviation_to_full = {v: k for k, v in state_abbreviations.items()}

                # Function to map full state names to abbreviations (if not already done for Net data)
                def map_state_names(df, state_col='State'):
                    df[state_col] = df[state_col].map(lambda x: state_abbreviations.get(x, x))
                    return df

                # Apply the mapping if not already done for Net data
                if store_type != "Net":
                    mapped_data = map_state_names(data.copy())
                    mapped_opened_by_state = map_state_names(opened_by_state.copy())
                else:
                    # For Net data, we already have the correct state names, just need to map them
                    mapped_opened_by_state = opened_by_state.copy()
                    # Map full state names to abbreviations for Net data
                    mapped_opened_by_state['State'] = mapped_opened_by_state['State'].map(lambda x: state_abbreviations.get(x, x))

                # --- 1) Build a full 50-state dataframe (0 for states with no data) ---
                all_states = pd.DataFrame({"State": sorted(abbreviation_to_full.keys())})
                opened_by_state_full = (
                    all_states
                    .merge(mapped_opened_by_state[["State", "Opened Stores"]], on="State", how="left")
                    .fillna({"Opened Stores": 0})
                )
                
                # Use apply instead of map to avoid type issues
                opened_by_state_full["State_Full"] = opened_by_state_full["State"].apply(lambda x: abbreviation_to_full.get(x, x))

                # --- Per-state metadata (0s for empty states) ---
                # For Net data, we need to calculate metadata differently
                if store_type == "Net" and 'data_from' in data.columns:
                    state_metadata = {}
                    for s in opened_by_state_full["State"]:
                        # Get data for this state
                        state_data = data[data['State'] == abbreviation_to_full.get(s, s)]
                        # Calculate metadata for both opened and closed data
                        opened_data = state_data[state_data['data_from'] == 'opened']
                        closed_data = state_data[state_data['data_from'] == 'closed']
                        
                        state_metadata[s] = {
                            "num_sectors": pd.concat([opened_data["Sector_Coresight"], closed_data["Sector_Coresight"]]).nunique() if "Sector_Coresight" in data.columns else 0,
                            "num_banners": pd.concat([opened_data["ChainName_Coresight"], closed_data["ChainName_Coresight"]]).nunique() if "ChainName_Coresight" in data.columns else 0,
                            "num_msa": pd.concat([opened_data["MsaName"], closed_data["MsaName"]]).nunique() if "MsaName" in data.columns else 0,
                        }
                else:
                    state_metadata = {}
                    for s in opened_by_state_full["State"]:
                        sd = mapped_data[mapped_data["State"] == s]
                        state_metadata[s] = {
                            "num_sectors": sd["Sector_Coresight"].nunique() if "Sector_Coresight" in sd.columns else 0,
                            "num_banners": sd["ChainName_Coresight"].nunique() if "ChainName_Coresight" in sd.columns else 0,
                            "num_msa":     sd["MsaName"].nunique() if "MsaName" in sd.columns else 0,
                        }

                # --- Date period ---
                start_date = data["Period"].min()
                end_date   = data["Period"].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str   = end_date.strftime("%b %Y")
                date_period = f"{start_date_str} to {end_date_str}"

                # --- Choropleth over ALL states (zeros included) ---
                zmax = int(opened_by_state_full["Opened Stores"].max()) or 1
                
                # Approximate center coordinates for each state
                state_centers = {
                    'AL': (-86.7, 32.7), 'AK': (-152.4, 64.2), 'AZ': (-111.9, 34.3), 'AR': (-92.4, 34.8),
                    'CA': (-119.4, 37.3), 'CO': (-105.5, 39.0), 'CT': (-72.7, 41.6), 'DE': (-75.5, 39.0),
                    'DC': (-77.0, 38.9), 'FL': (-82.5, 27.8), 'GA': (-83.4, 32.6), 'HI': (-157.5, 20.9),
                    'ID': (-114.4, 44.2), 'IL': (-89.4, 40.0), 'IN': (-86.2, 40.3), 'IA': (-93.5, 42.1),
                    'KS': (-98.3, 38.5), 'KY': (-85.0, 37.5), 'LA': (-91.1, 30.9), 'ME': (-69.4, 45.3),
                    'MD': (-76.6, 39.0), 'MA': (-71.8, 42.3), 'MI': (-84.5, 44.2), 'MN': (-94.3, 46.3),
                    'MS': (-89.7, 32.7), 'MO': (-92.6, 38.5), 'MT': (-110.0, 46.9), 'NE': (-99.9, 41.5),
                    'NV': (-116.6, 39.3), 'NH': (-71.6, 43.7), 'NJ': (-74.4, 40.1), 'NM': (-106.0, 34.5),
                    'NY': (-75.5, 43.0), 'NC': (-79.0, 35.6), 'ND': (-100.5, 47.6), 'OH': (-82.8, 40.4),
                    'OK': (-97.5, 35.5), 'OR': (-120.6, 43.8), 'PA': (-77.2, 40.9), 'RI': (-71.5, 41.7),
                    'SC': (-80.9, 33.9), 'SD': (-100.4, 44.4), 'TN': (-86.6, 35.7), 'TX': (-99.9, 31.5),
                    'UT': (-111.6, 39.3), 'VT': (-72.7, 44.0), 'VA': (-78.9, 37.8), 'WA': (-120.7, 47.5),
                    'WV': (-80.6, 38.5), 'WI': (-89.9, 44.5), 'WY': (-107.6, 43.1), 'PR': (-66.5, 18.2)
                }

                fig_opened_map = px.choropleth(
                    opened_by_state_full,
                    locations="State",
                    locationmode="USA-states",
                    color="Opened Stores",
                    range_color=(0, zmax),
                    color_continuous_scale=["#ffffff", color],
                    scope="usa",
                    hover_name="State_Full",
                    hover_data={"State": False}  # keep hover clean; we'll control with hovertemplate
                )

                # Hover matches your style (with metadata + date period)
                fig_opened_map.update_traces(
                    hovertemplate=(
                        "<b>%{hovertext}</b><br>"
                        f"<span style='color:{color}'>●</span> <b>{store_type} Stores:</b> %{{z:,}}<br><br>"
                        f"<span style='color:{color}'>•</span> <span style='color:black'>Date Period: " + date_period + "</span><br>"
                        f"<span style='color:{color}'>•</span> <span style='color:black'>Number of Sectors: %{{customdata[0]:,}}</span><br>"
                        f"<span style='color:{color}'>•</span> <span style='color:black'>Number of Banners: %{{customdata[1]:,}}</span><br>"
                        f"<span style='color:{color}'>•</span> <span style='color:black'>Number of MSA: %{{customdata[2]:,}}</span><br>"
                        "<extra></extra>"
                    ),
                    customdata=[[state_metadata[s]["num_sectors"], state_metadata[s]["num_banners"], state_metadata[s]["num_msa"]] for s in opened_by_state_full["State"]],
                    hoverlabel=dict(bgcolor="white", bordercolor=color, font=dict(size=13, color="black", family="Arial")),
                )

                # Colorbar title like the reference
                fig_opened_map.update_coloraxes(colorbar_title=f"{store_type} Stores")

                # Layout to match the reference's look
                fig_opened_map.update_layout(
                    margin=dict(l=0, r=0, t=0, b=0),
                    geo=dict(
                        projection_scale=1.2,
                        center=dict(lat=37.5, lon=-95),
                        showlakes=True, lakecolor="rgb(255,255,255)",
                        showframe=False, showcoastlines=False
                    )
                )

                # --- Text labels ONLY for states with data (>0), avoiding overlaps ---
                ann_df = opened_by_state_full[opened_by_state_full["Opened Stores"] != 0]  # For Net, show non-zero values
                excluded_states = detect_overlapping_states_by_count(ann_df, state_centers)  # your helper
                
                # Convert excluded_states to a list for pandas isin method
                excluded_states_list = list(excluded_states)
                
                # Convert ann_df["State"] to a pandas Series to use isin method
                state_series = pd.Series(ann_df["State"])
                ann_df = ann_df[~state_series.isin(excluded_states_list)]

                annotations_opened = go.Scattergeo(
                    locationmode="USA-states",
                    lon=[state_centers[s][0] for s in ann_df["State"] if s in state_centers],
                    lat=[state_centers[s][1] for s in ann_df["State"] if s in state_centers],
                    text=[f"{s}<br>{cnt:,}" for s, cnt in zip(ann_df["State"], ann_df["Opened Stores"]) if s in state_centers],
                    mode="text",
                    showlegend=False,
                    textfont=dict(size=11, color="black"),
                    hoverinfo="skip"
                )
                fig_opened_map.add_trace(annotations_opened)

                if column:
                    with column:
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores by State</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_map, use_container_width=True)
                else:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores by State</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_map, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating map: {e}")
            else:
                st.write(f"Error creating map: {e}")
                
    @staticmethod
    def render_opened_cities_bar_chart(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened cities bar chart"""
        try:
            opened_store_counts = data['City'].value_counts().head(15)
            y_max_opened = UIComponents.calculate_yaxis_limit(opened_store_counts.max())

            # Calculate metadata for each city
            city_metadata = {}
            for city in opened_store_counts.index:
                city_data = data[data['City'] == city]
                city_metadata[city] = {
                    'num_sectors': city_data['Sector_Coresight'].nunique(),
                    'num_banners': city_data['ChainName_Coresight'].nunique(),
                    'num_states': city_data['State'].nunique(),
                    'num_msa': city_data['MsaName'].nunique()
                }

            # Calculate overall date range
            start_date = data['Period'].min()
            end_date   = data['Period'].max()
            start_date_str = start_date.strftime("%B %Y")
            end_date_str   = end_date.strftime("%B %Y")
            date_period = f"{start_date_str} to {end_date_str}"

            # Create figure with consistent styling
            fig_opened_bar = go.Figure()

            fig_opened_bar.add_trace(go.Bar(
                x=opened_store_counts.index,
                y=opened_store_counts.values,
                marker_color=color,
                text=[f"{x:,}" for x in opened_store_counts.values],
                textposition='outside',
                hovertemplate=(
                    "<b>%{x}</b><br>"  # City name
                    f"<span style='color:{color}'>●</span> "
                    f"<b>{store_type} Stores:</b> %{{y:,}}<br><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Date Period: " + f"{date_period}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of Sectors: %{customdata[0]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of Banners: %{customdata[1]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of States: %{customdata[2]}</span><br>"
                    f"<span style='color:{color}'>•</span> "
                    "<span style='color:black'>Number of MSA: %{customdata[3]}</span><br>"
                    "<extra></extra>"
                ),
                customdata=[[city_metadata[city]['num_sectors'], city_metadata[city]['num_banners'], city_metadata[city]['num_states'], city_metadata[city]['num_msa']] for city in opened_store_counts.index],
                hoverlabel=dict(
                    bgcolor="white",
                    bordercolor=color,
                    font=dict(size=13, color="black", family="Arial")
                )
            ))

            fig_opened_bar.update_layout(
                xaxis_title="City",
                yaxis_title=f"{store_type} Stores",
                yaxis=dict(
                    range=[0, y_max_opened],
                    autorange=False,
                    showline=True,
                    zeroline=False
                ),
                xaxis=dict(
                    showline=True,
                    zeroline=False,
                    tickangle=45 if len(opened_store_counts) > 5 else 0  # Auto-rotate if many cities
                ),
                height=450,  # Increased height to accommodate additional hover info
                margin=dict(l=20, r=20, t=60, b=40),  # Adjusted margins
                uniformtext_minsize=8,
                uniformtext_mode='hide'
            )

            # Additional label rotation for many cities
            if len(opened_store_counts) > 8:
                fig_opened_bar.update_layout(
                    xaxis=dict(tickangle=60),
                    margin=dict(b=60)  # Extra bottom margin
                )

            # Bar Chart in column
            if column:
                with column:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {opened_store_counts.shape[0]} Cities</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_bar, use_container_width=True)
            else:
                st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {opened_store_counts.shape[0]} Cities</h4>", unsafe_allow_html=True)
                st.plotly_chart(fig_opened_bar, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating chart: {e}")
            else:
                st.write(f"Error creating chart: {e}")
                
    @staticmethod
    def render_opened_stores_per_capita_map(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened stores per capita map"""
        try:
            opened_by_state = data.groupby('State').agg(
                Opened_Stores=('State', 'size'),  # Count the number of closed stores per state
                Population=('Population', 'max')  # Get the max (distinct) population for each state
            ).reset_index()

            opened_by_state['Opened Stores per Capita'] = opened_by_state.apply(
                lambda row: (row['Opened_Stores'] / row['Population']) * 1_000_000 if row['Population'] > 0 else float('nan'),
                axis=1
            )

            opened_by_state = opened_by_state.dropna(subset=['Opened Stores per Capita'])

            if opened_by_state.empty or opened_by_state['State'].isna().all():
                end_date_str = data['Period'].max().strftime('%B %Y')
                date_suffix = f" for {end_date_str}" if store_type == "Active" else ""
                if column:
                    with column:
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center; color: red; font-weight: bold; margin-top: 100px;'>No data available for per capita map{date_suffix}</h4>", unsafe_allow_html=True)
                else:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center; color: red; font-weight: bold; margin-top: 100px;'>No data available for per capita map{date_suffix}</h4>", unsafe_allow_html=True)
            else:
                import math

                def calculate_distance(lat1, lon1, lat2, lon2):
                    """Calculate distance between two points on map"""
                    return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)

                def detect_overlapping_states(opened_by_state, state_centers, min_distance=1.5):
                    """
                    Detect states that are too close to each other and would cause overlapping text
                    Returns a list of states to exclude from annotations
                    """
                    states_to_exclude = set()
                    
                    # Known problematic clusters in the Northeast and small states
                    northeast_clusters = [
                        ['CT', 'RI', 'MA'],  # Connecticut, Rhode Island, Massachusetts cluster
                        ['VT', 'NH', 'ME'],  # Vermont, New Hampshire, Maine cluster
                        ['NJ', 'DE', 'MD'],  # New Jersey, Delaware, Maryland cluster
                    ]
                    
                    # Additional states to always exclude (small or problematic positioning)
                    always_exclude = ['ME', 'MA', 'DC', 'WV']
                    
                    # Add always excluded states
                    for state in always_exclude:
                        if state in opened_by_state['State'].values:
                            states_to_exclude.add(state)
                    
                    # Check each cluster and keep only the state with highest value
                    for cluster in northeast_clusters:
                        cluster_states = [state for state in cluster if state in opened_by_state['State'].values]
                        if len(cluster_states) > 1:
                            # Find the state with highest per capita value in this cluster
                            cluster_data = opened_by_state[opened_by_state['State'].isin(cluster_states)]
                            max_state = cluster_data.loc[cluster_data['Opened Stores per Capita'].idxmax(), 'State']
                            
                            # Exclude all others in the cluster
                            for state in cluster_states:
                                if state != max_state:
                                    states_to_exclude.add(state)
                    
                    # Additional proximity check for any remaining states
                    remaining_states = [state for state in opened_by_state['State'] if state not in states_to_exclude]
                    
                    for i, state1 in enumerate(remaining_states):
                        if state1 in states_to_exclude:
                            continue
                            
                        for state2 in remaining_states[i+1:]:
                            if state2 in states_to_exclude:
                                continue
                                
                            if state1 in state_centers and state2 in state_centers:
                                distance = calculate_distance(
                                    state_centers[state1][1], state_centers[state1][0],
                                    state_centers[state2][1], state_centers[state2][0]
                                )
                                
                                if distance < min_distance:
                                    # Keep the state with higher per capita value
                                    state1_value = opened_by_state[opened_by_state['State'] == state1]['Opened Stores per Capita'].iloc[0]
                                    state2_value = opened_by_state[opened_by_state['State'] == state2]['Opened Stores per Capita'].iloc[0]
                                    
                                    if state1_value < state2_value:
                                        states_to_exclude.add(state1)
                                    else:
                                        states_to_exclude.add(state2)
                    
                    return list(states_to_exclude)

                # Dictionary to convert full state names to two-letter abbreviations
                state_abbreviations = {
                    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR',
                    'California': 'CA', 'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE',
                    'District of Columbia': 'DC', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI',
                    'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS',
                    'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
                    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
                    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV',
                    'New Hampshire': 'NH', 'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY',
                    'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
                    'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
                    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
                    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV',
                    'Wisconsin': 'WI', 'Wyoming': 'WY', 'Puerto Rico': 'PR'
                }

                # Create reverse dictionary to convert abbreviations to full names
                abbreviation_to_full = {v: k for k, v in state_abbreviations.items()}

                # Function to map full state names to abbreviations
                def map_state_names(df, state_col='State'):
                    df[state_col] = df[state_col].map(lambda x: state_abbreviations.get(x, x))
                    return df

                # Apply the mapping
                mapped_data = map_state_names(data.copy())

                # Group opened data by state
                opened_by_state = mapped_data.groupby('State').size().reset_index(name='Opened Stores')
                opened_by_state = opened_by_state.dropna()  # Drop any rows with unmapped states

                if opened_by_state.empty or opened_by_state['State'].isna().all():
                    if column:
                        with column:
                            st.write("No state data available for map display.")
                    else:
                        st.write("No state data available for map display.")
                else:
                    import math

                    def calculate_distance(lat1, lon1, lat2, lon2):
                        """Calculate distance between two points on map"""
                        return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)

                    def detect_overlapping_states_by_count(opened_by_state, state_centers, min_distance=1.5):
                        """
                        Detect states that are too close to each other and would cause overlapping text
                        Returns a list of states to exclude from annotations
                        """
                        states_to_exclude = set()
                        
                        # Known problematic clusters in the Northeast and small states
                        northeast_clusters = [
                            ['CT', 'RI', 'MA'],  # Connecticut, Rhode Island, Massachusetts cluster
                            ['VT', 'NH', 'ME'],  # Vermont, New Hampshire, Maine cluster
                            ['NJ', 'DE', 'MD'],  # New Jersey, Delaware, Maryland cluster
                        ]
                        
                        # Additional states to always exclude (small or problematic positioning)
                        always_exclude = ['ME', 'MA', 'DC', 'WV']
                        
                        # Add always excluded states
                        for state in always_exclude:
                            if state in opened_by_state['State'].values:
                                states_to_exclude.add(state)
                        
                        # Check each cluster and keep only the state with highest value
                        for cluster in northeast_clusters:
                            cluster_states = [state for state in cluster if state in opened_by_state['State'].values]
                            if len(cluster_states) > 1:
                                # Find the state with highest store count in this cluster
                                cluster_data = opened_by_state[opened_by_state['State'].isin(cluster_states)]
                                max_state = cluster_data.loc[cluster_data['Opened Stores'].idxmax(), 'State']
                                
                                # Exclude all others in the cluster
                                for state in cluster_states:
                                    if state != max_state:
                                        states_to_exclude.add(state)
                        
                        # Additional proximity check for any remaining states
                        remaining_states = [state for state in opened_by_state['State'] if state not in states_to_exclude]
                        
                        for i, state1 in enumerate(remaining_states):
                            if state1 in states_to_exclude:
                                continue
                                
                            for state2 in remaining_states[i+1:]:
                                if state2 in states_to_exclude:
                                    continue
                                    
                                if state1 in state_centers and state2 in state_centers:
                                    distance = calculate_distance(
                                        state_centers[state1][1], state_centers[state1][0],
                                        state_centers[state2][1], state_centers[state2][0]
                                    )
                                    
                                    if distance < min_distance:
                                        # Keep the state with higher store count
                                        state1_value = opened_by_state[opened_by_state['State'] == state1]['Opened Stores'].iloc[0]
                                        state2_value = opened_by_state[opened_by_state['State'] == state2]['Opened Stores'].iloc[0]
                                        
                                        if state1_value < state2_value:
                                            states_to_exclude.add(state1)
                                        else:
                                            states_to_exclude.add(state2)
                        
                        return list(states_to_exclude)

                    # Create reverse dictionary to convert abbreviations to full names
                    abbreviation_to_full = {v: k for k, v in state_abbreviations.items()}

                    # Add full state name column to the dataframe
                    # --- 1) Build a full 50-state dataframe (0 for states with no data) ---
                    all_states = pd.DataFrame({"State": sorted(abbreviation_to_full.keys())})
                    opened_by_state_full = (
                        all_states
                        .merge(opened_by_state[["State", "Opened Stores"]], on="State", how="left")
                        .fillna({"Opened Stores": 0})
                    )
                    
                    # Use apply instead of map to avoid type issues
                    opened_by_state_full["State_Full"] = opened_by_state_full["State"].apply(lambda x: abbreviation_to_full.get(x, x))

                    # --- Per-state metadata (0s for empty states) ---
                    state_metadata = {}
                    for s in opened_by_state_full["State"]:
                        sd = mapped_data[mapped_data["State"] == s]
                        state_metadata[s] = {
                            "num_sectors": sd["Sector_Coresight"].nunique() if "Sector_Coresight" in sd.columns else 0,
                            "num_banners": sd["ChainName_Coresight"].nunique() if "ChainName_Coresight" in sd.columns else 0,
                            "num_msa":     sd["MsaName"].nunique() if "MsaName" in sd.columns else 0,
                        }

                    # --- Date period ---
                    start_date = mapped_data["Period"].min()
                    end_date   = mapped_data["Period"].max()
                    start_date_str = start_date.strftime("%b %Y")
                    end_date_str   = end_date.strftime("%b %Y")
                    date_period = f"{start_date_str} to {end_date_str}"

                    # --- Choropleth over ALL states (zeros included) ---
                    zmax = int(opened_by_state_full["Opened Stores"].max()) or 1
                    
                    # Approximate center coordinates for each state
                    state_centers = {
                        'AL': (-86.7, 32.7), 'AK': (-152.4, 64.2), 'AZ': (-111.9, 34.3), 'AR': (-92.4, 34.8),
                        'CA': (-119.4, 37.3), 'CO': (-105.5, 39.0), 'CT': (-72.7, 41.6), 'DE': (-75.5, 39.0),
                        'DC': (-77.0, 38.9), 'FL': (-82.5, 27.8), 'GA': (-83.4, 32.6), 'HI': (-157.5, 20.9),
                        'ID': (-114.4, 44.2), 'IL': (-89.4, 40.0), 'IN': (-86.2, 40.3), 'IA': (-93.5, 42.1),
                        'KS': (-98.3, 38.5), 'KY': (-85.0, 37.5), 'LA': (-91.1, 30.9), 'ME': (-69.4, 45.3),
                        'MD': (-76.6, 39.0), 'MA': (-71.8, 42.3), 'MI': (-84.5, 44.2), 'MN': (-94.3, 46.3),
                        'MS': (-89.7, 32.7), 'MO': (-92.6, 38.5), 'MT': (-110.0, 46.9), 'NE': (-99.9, 41.5),
                        'NV': (-116.6, 39.3), 'NH': (-71.6, 43.7), 'NJ': (-74.4, 40.1), 'NM': (-106.0, 34.5),
                        'NY': (-75.5, 43.0), 'NC': (-79.0, 35.6), 'ND': (-100.5, 47.6), 'OH': (-82.8, 40.4),
                        'OK': (-97.5, 35.5), 'OR': (-120.6, 43.8), 'PA': (-77.2, 40.9), 'RI': (-71.5, 41.7),
                        'SC': (-80.9, 33.9), 'SD': (-100.4, 44.4), 'TN': (-86.6, 35.7), 'TX': (-99.9, 31.5),
                        'UT': (-111.6, 39.3), 'VT': (-72.7, 44.0), 'VA': (-78.9, 37.8), 'WA': (-120.7, 47.5),
                        'WV': (-80.6, 38.5), 'WI': (-89.9, 44.5), 'WY': (-107.6, 43.1), 'PR': (-66.5, 18.2)
                    }

                    fig_opened_map = px.choropleth(
                        opened_by_state_full,
                        locations="State",
                        locationmode="USA-states",
                        color="Opened Stores",
                        range_color=(0, zmax),
                        color_continuous_scale=["#ffffff", color],
                        scope="usa",
                        hover_name="State_Full",
                        hover_data={"State": False}  # keep hover clean; we'll control with hovertemplate
                    )

                    # Hover matches your style (with metadata + date period)
                    fig_opened_map.update_traces(
                        hovertemplate=(
                            "<b>%{hovertext}</b><br>"
                            f"<span style='color:{color}'>●</span> <b>{store_type} Stores:</b> %{{z:,}}<br><br>"
                            f"<span style='color:{color}'>•</span> <span style='color:black'>Date Period: " + date_period + "</span><br>"
                            f"<span style='color:{color}'>•</span> <span style='color:black'>Number of Sectors: %{{customdata[0]:,}}</span><br>"
                            f"<span style='color:{color}'>•</span> <span style='color:black'>Number of Banners: %{{customdata[1]:,}}</span><br>"
                            f"<span style='color:{color}'>•</span> <span style='color:black'>Number of MSA: %{{customdata[2]:,}}</span><br>"
                            "<extra></extra>"
                        ),
                        customdata=[[state_metadata[s]["num_sectors"], state_metadata[s]["num_banners"], state_metadata[s]["num_msa"]] for s in opened_by_state_full["State"]],
                        hoverlabel=dict(bgcolor="white", bordercolor=color, font=dict(size=13, color="black", family="Arial")),
                    )

                    # Colorbar title like the reference
                    fig_opened_map.update_coloraxes(colorbar_title=f"{store_type} Stores")

                    # Layout to match the reference's look
                    fig_opened_map.update_layout(
                        margin=dict(l=0, r=0, t=0, b=0),
                        geo=dict(
                            projection_scale=1.2,
                            center=dict(lat=37.5, lon=-95),
                            showlakes=True, lakecolor="rgb(255,255,255)",
                            showframe=False, showcoastlines=False
                        )
                    )

                    # --- Text labels ONLY for states with data (>0), avoiding overlaps ---
                    ann_df = opened_by_state_full[opened_by_state_full["Opened Stores"] > 0]
                    excluded_states = detect_overlapping_states_by_count(ann_df, state_centers)  # your helper
                    
                    # Convert excluded_states to a list for pandas isin method
                    excluded_states_list = list(excluded_states)
                    
                    # Convert ann_df["State"] to a pandas Series to use isin method
                    state_series = pd.Series(ann_df["State"])
                    ann_df = ann_df[~state_series.isin(excluded_states_list)]

                    annotations_opened = go.Scattergeo(
                        locationmode="USA-states",
                        lon=[state_centers[s][0] for s in ann_df["State"] if s in state_centers],
                        lat=[state_centers[s][1] for s in ann_df["State"] if s in state_centers],
                        text=[f"{s}<br>{cnt:,}" for s, cnt in zip(ann_df["State"], ann_df["Opened Stores"]) if s in state_centers],
                        mode="text",
                        showlegend=False,
                        textfont=dict(size=11, color="black"),
                        hoverinfo="skip"
                    )
                    fig_opened_map.add_trace(annotations_opened)

                    if column:
                        with column:
                            st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores by State</h4>", unsafe_allow_html=True)
                            st.plotly_chart(fig_opened_map, use_container_width=True)
                    else:
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores by State</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_map, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating map: {e}")
            else:
                st.write(f"Error creating map: {e}")
                
    @staticmethod
    def render_opened_stores_per_capita_map(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened stores per capita map"""
        try:
            # For Net data, calculate net openings (opened - closed)
            if store_type == "Net" and 'data_from' in data.columns:
                # Group by State and data_from to get counts for each
                state_data = data.groupby(['State', 'data_from']).agg(
                    Count=('State', 'size'),
                    Population=('Population', 'max')
                ).reset_index()
                
                # Pivot to get opened and closed counts as separate columns
                state_pivot = state_data.pivot_table(index='State', columns='data_from', values=['Count', 'Population'], aggfunc='first').fillna(0)
                
                # Extract counts and populations
                opened_counts = state_pivot[('Count', 'opened')] if ('Count', 'opened') in state_pivot.columns else pd.Series(0, index=state_pivot.index)
                closed_counts = state_pivot[('Count', 'closed')] if ('Count', 'closed') in state_pivot.columns else pd.Series(0, index=state_pivot.index)
                # For population, use the opened population as the base (following original logic)
                populations = state_pivot[('Population', 'opened')] if ('Population', 'opened') in state_pivot.columns else pd.Series(0, index=state_pivot.index)
                
                # Calculate net openings
                net_counts = opened_counts - closed_counts
                
                # Create DataFrame with net counts and populations
                opened_by_state = pd.DataFrame({
                    'State': net_counts.index,
                    'Opened_Stores': net_counts.values,
                    'Population': populations.values
                })
                
                # Calculate per capita values
                opened_by_state['Opened Stores per Capita'] = opened_by_state.apply(
                    lambda row: (row['Opened_Stores'] / row['Population']) * 1_000_000 if row['Population'] > 0 else float('nan'),
                    axis=1
                )
                
                # Remove rows with NaN per capita values
                opened_by_state = opened_by_state.dropna(subset=['Opened Stores per Capita'])
            else:
                opened_by_state = data.groupby('State').agg(
                    Opened_Stores=('State', 'size'),  # Count the number of closed stores per state
                    Population=('Population', 'max')  # Get the max (distinct) population for each state
                ).reset_index()

                opened_by_state['Opened Stores per Capita'] = opened_by_state.apply(
                    lambda row: (row['Opened_Stores'] / row['Population']) * 1_000_000 if row['Population'] > 0 else float('nan'),
                    axis=1
                )

                opened_by_state = opened_by_state.dropna(subset=['Opened Stores per Capita'])

            if opened_by_state.empty or opened_by_state['State'].isna().all():
                end_date_str = data['Period'].max().strftime('%B %Y')
                date_suffix = f" for {end_date_str}" if store_type == "Active" else ""
                if column:
                    with column:
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center; color: red; font-weight: bold; margin-top: 100px;'>No data available for per capita map{date_suffix}</h4>", unsafe_allow_html=True)
                else:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center; color: red; font-weight: bold; margin-top: 100px;'>No data available for per capita map{date_suffix}</h4>", unsafe_allow_html=True)
            else:
                import math

                def calculate_distance(lat1, lon1, lat2, lon2):
                    """Calculate distance between two points on map"""
                    return math.sqrt((lat2 - lat1)**2 + (lon2 - lon1)**2)

                def detect_overlapping_states(opened_by_state, state_centers, min_distance=1.5):
                    """
                    Detect states that are too close to each other and would cause overlapping text
                    Returns a list of states to exclude from annotations
                    """
                    states_to_exclude = set()
                    
                    # Known problematic clusters in the Northeast and small states
                    northeast_clusters = [
                        ['CT', 'RI', 'MA'],  # Connecticut, Rhode Island, Massachusetts cluster
                        ['VT', 'NH', 'ME'],  # Vermont, New Hampshire, Maine cluster
                        ['NJ', 'DE', 'MD'],  # New Jersey, Delaware, Maryland cluster
                    ]
                    
                    # Additional states to always exclude (small or problematic positioning)
                    always_exclude = ['ME', 'MA', 'DC', 'WV']
                    
                    # Add always excluded states
                    for state in always_exclude:
                        if state in opened_by_state['State'].values:
                            states_to_exclude.add(state)
                    
                    # Check each cluster and keep only the state with highest value
                    for cluster in northeast_clusters:
                        cluster_states = [state for state in cluster if state in opened_by_state['State'].values]
                        if len(cluster_states) > 1:
                            # Find the state with highest per capita value in this cluster
                            cluster_data = opened_by_state[opened_by_state['State'].isin(cluster_states)]
                            max_state = cluster_data.loc[cluster_data['Opened Stores per Capita'].idxmax(), 'State']
                            
                            # Exclude all others in the cluster
                            for state in cluster_states:
                                if state != max_state:
                                    states_to_exclude.add(state)
                    
                    # Additional proximity check for any remaining states
                    remaining_states = [state for state in opened_by_state['State'] if state not in states_to_exclude]
                    
                    for i, state1 in enumerate(remaining_states):
                        if state1 in states_to_exclude:
                            continue
                            
                        for state2 in remaining_states[i+1:]:
                            if state2 in states_to_exclude:
                                continue
                                
                            if state1 in state_centers and state2 in state_centers:
                                distance = calculate_distance(
                                    state_centers[state1][1], state_centers[state1][0],
                                    state_centers[state2][1], state_centers[state2][0]
                                )
                                
                                if distance < min_distance:
                                    # Keep the state with higher per capita value
                                    state1_value = opened_by_state[opened_by_state['State'] == state1]['Opened Stores per Capita'].iloc[0]
                                    state2_value = opened_by_state[opened_by_state['State'] == state2]['Opened Stores per Capita'].iloc[0]
                                    
                                    if state1_value < state2_value:
                                        states_to_exclude.add(state1)
                                    else:
                                        states_to_exclude.add(state2)
                    
                    return list(states_to_exclude)

                # Dictionary to convert full state names to two-letter abbreviations
                state_abbreviations = {
                    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR',
                    'California': 'CA', 'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE',
                    'District of Columbia': 'DC', 'Florida': 'FL', 'Georgia': 'GA', 'Hawaii': 'HI',
                    'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA', 'Kansas': 'KS',
                    'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
                    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',
                    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV',
                    'New Hampshire': 'NH', 'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY',
                    'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK',
                    'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
                    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
                    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV',
                    'Wisconsin': 'WI', 'Wyoming': 'WY', 'Puerto Rico': 'PR'
                }

                # Create reverse dictionary to convert abbreviations to full names
                abbreviation_to_full = {v: k for k, v in state_abbreviations.items()}

                # Function to map full state names to abbreviations
                def map_state_names(df, state_col='State'):
                    df[state_col] = df[state_col].map(lambda x: state_abbreviations.get(x, x))
                    return df

                # Apply the mapping
                mapped_data = map_state_names(data.copy())

                # --- 1) Build a full 50-state dataframe (0 for states with no data) ---
                all_states = pd.DataFrame({"State": sorted(abbreviation_to_full.keys())})
                
                # For Net data, we already have the correct data structure
                if store_type == "Net":
                    mapped_opened_by_state = map_state_names(opened_by_state.copy())
                else:
                    # For regular data, we need to group by state
                    mapped_opened_by_state = mapped_data.groupby('State').size().reset_index(name='Opened Stores')
                    mapped_opened_by_state = mapped_opened_by_state.dropna()  # Drop any rows with unmapped states

                # --- Per-state metadata (0s for empty states) ---
                state_metadata = {}
                for s in all_states["State"]:
                    sd = mapped_data[mapped_data["State"] == s]
                    state_metadata[s] = {
                        "num_sectors": sd["Sector_Coresight"].nunique() if "Sector_Coresight" in sd.columns else 0,
                        "num_banners": sd["ChainName_Coresight"].nunique() if "ChainName_Coresight" in sd.columns else 0,
                        "num_msa":     sd["MsaName"].nunique() if "MsaName" in sd.columns else 0,
                    }

                # --- Date period ---
                start_date = mapped_data["Period"].min()
                end_date   = mapped_data["Period"].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str   = end_date.strftime("%b %Y")
                date_period = f"{start_date_str} to {end_date_str}"

                # --- Choropleth over ALL states (zeros included) ---
                zmax = int(opened_by_state["Opened Stores per Capita"].max()) or 1
                
                # Approximate center coordinates for each state
                state_centers = {
                    'AL': (-86.7, 32.7), 'AK': (-152.4, 64.2), 'AZ': (-111.9, 34.3), 'AR': (-92.4, 34.8),
                    'CA': (-119.4, 37.3), 'CO': (-105.5, 39.0), 'CT': (-72.7, 41.6), 'DE': (-75.5, 39.0),
                    'DC': (-77.0, 38.9), 'FL': (-82.5, 27.8), 'GA': (-83.4, 32.6), 'HI': (-157.5, 20.9),
                    'ID': (-114.4, 44.2), 'IL': (-89.4, 40.0), 'IN': (-86.2, 40.3), 'IA': (-93.5, 42.1),
                    'KS': (-98.3, 38.5), 'KY': (-85.0, 37.5), 'LA': (-91.1, 30.9), 'ME': (-69.4, 45.3),
                    'MD': (-76.6, 39.0), 'MA': (-71.8, 42.3), 'MI': (-84.5, 44.2), 'MN': (-94.3, 46.3),
                    'MS': (-89.7, 32.7), 'MO': (-92.6, 38.5), 'MT': (-110.0, 46.9), 'NE': (-99.9, 41.5),
                    'NV': (-116.6, 39.3), 'NH': (-71.6, 43.7), 'NJ': (-74.4, 40.1), 'NM': (-106.0, 34.5),
                    'NY': (-75.5, 43.0), 'NC': (-79.0, 35.6), 'ND': (-100.5, 47.6), 'OH': (-82.8, 40.4),
                    'OK': (-97.5, 35.5), 'OR': (-120.6, 43.8), 'PA': (-77.2, 40.9), 'RI': (-71.5, 41.7),
                    'SC': (-80.9, 33.9), 'SD': (-100.4, 44.4), 'TN': (-86.6, 35.7), 'TX': (-99.9, 31.5),
                    'UT': (-111.6, 39.3), 'VT': (-72.7, 44.0), 'VA': (-78.9, 37.8), 'WA': (-120.7, 47.5),
                    'WV': (-80.6, 38.5), 'WI': (-89.9, 44.5), 'WY': (-107.6, 43.1), 'PR': (-66.5, 18.2)
                }

                fig_opened_map = px.choropleth(
                    opened_by_state,
                    locations="State",
                    locationmode="USA-states",
                    color="Opened Stores per Capita",
                    color_continuous_scale=["#ffffff", color],
                    scope="usa",
                    hover_name="State",
                    hover_data={"State": False}  # Only show what we specify in hovertemplate
                )

                # Calculate metadata for each state
                state_metadata = {}
                for state in opened_by_state['State']:
                    state_data = mapped_data[mapped_data['State'] == state]
                    state_metadata[state] = {
                        'num_sectors': state_data['Sector_Coresight'].nunique() if 'Sector_Coresight' in state_data.columns else 0,
                        'num_banners': state_data['ChainName_Coresight'].nunique() if 'ChainName_Coresight' in state_data.columns else 0,
                        'num_msa': state_data['MsaName'].nunique() if 'MsaName' in state_data.columns else 0
                    }

                # Calculate overall date range
                start_date = mapped_data['Period'].min()
                end_date = mapped_data['Period'].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str   = end_date.strftime("%b %Y")

                date_period = f"{start_date_str} to {end_date_str}"

                # Customize hover template with state-specific metadata
                fig_opened_map.update_traces(
                    hovertemplate=(
                        "<b>%{hovertext}</b><br>"  # State name
                        f"<span style='color:{color}'>●</span> "
                        "<b>Stores per Million:</b> %{z:,.2f}<br><br>"  # Per capita value
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Date Period: {date_period}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of Sectors: %{customdata[0]:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of Banners: %{customdata[1]:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of MSA: %{customdata[2]:,}</span><br>"
                        "<extra></extra>"
                    ),
                    customdata=[[state_metadata[state]['num_sectors'], state_metadata[state]['num_banners'], state_metadata[state]['num_msa']] for state in opened_by_state['State']],
                    hoverlabel=dict(
                        bgcolor="white",
                        bordercolor=color,
                        font=dict(size=13, color="black", family="Arial")
                    )
                )

                fig_opened_map.update_coloraxes(
                    colorbar_title=f"{store_type} Stores per Million Capita"
                )

                # Customize layout
                fig_opened_map.update_layout(
                    margin=dict(l=0, r=0, t=0, b=0),
                    geo=dict(
                        projection_scale=1.2,
                        center=dict(lat=37.5, lon=-95),
                        showlakes=True,
                        lakecolor='rgb(255, 255, 255)',
                        showframe=False,
                        showcoastlines=False
                    )
                )

                # Approximate center coordinates for each state
                state_centers = {
                    'AL': (-86.7, 32.7), 'AK': (-152.4, 64.2), 'AZ': (-111.9, 34.3), 'AR': (-92.4, 34.8),
                    'CA': (-119.4, 37.3), 'CO': (-105.5, 39.0), 'CT': (-72.7, 41.6), 'DE': (-75.5, 39.0),
                    'DC': (-77.0, 38.9), 'FL': (-82.5, 27.8), 'GA': (-83.4, 32.6), 'HI': (-157.5, 20.9),
                    'ID': (-114.4, 44.2), 'IL': (-89.4, 40.0), 'IN': (-86.2, 40.3), 'IA': (-93.5, 42.1),
                    'KS': (-98.3, 38.5), 'KY': (-85.0, 37.5), 'LA': (-91.1, 30.9), 'ME': (-69.4, 45.3),
                    'MD': (-76.6, 39.0), 'MA': (-71.8, 42.3), 'MI': (-84.5, 44.2), 'MN': (-94.3, 46.3),
                    'MS': (-89.7, 32.7), 'MO': (-92.6, 38.5), 'MT': (-110.0, 46.9), 'NE': (-99.9, 41.5),
                    'NV': (-116.6, 39.3), 'NH': (-71.6, 43.7), 'NJ': (-74.4, 40.1), 'NM': (-106.0, 34.5),
                    'NY': (-75.5, 43.0), 'NC': (-79.0, 35.6), 'ND': (-100.5, 47.6), 'OH': (-82.8, 40.4),
                    'OK': (-97.5, 35.5), 'OR': (-120.6, 43.8), 'PA': (-77.2, 40.9), 'RI': (-71.5, 41.7),
                    'SC': (-80.9, 33.9), 'SD': (-100.4, 44.4), 'TN': (-86.6, 35.7), 'TX': (-99.9, 31.5),
                    'UT': (-111.6, 39.3), 'VT': (-72.7, 44.0), 'VA': (-78.9, 37.8), 'WA': (-120.7, 47.5),
                    'WV': (-80.6, 38.5), 'WI': (-89.9, 44.5), 'WY': (-107.6, 43.1), 'PR': (-66.5, 18.2)
                }

                # State annotations (with hover disabled)
                excluded_states = detect_overlapping_states(opened_by_state, state_centers)
                states_to_annotate = opened_by_state[~opened_by_state['State'].isin(list(excluded_states))]

                # Add Scattergeo layer for non-overlapping state annotations only
                annotations_opened = go.Scattergeo(
                    locationmode='USA-states',
                    lon=[state_centers[state][0] for state in states_to_annotate['State'] if state in state_centers],
                    lat=[state_centers[state][1] for state in states_to_annotate['State'] if state in state_centers],
                    text=[f"{state}<br>{opened_per_capita:,.2f}"
                        for state, opened_per_capita in zip(states_to_annotate['State'], 
                                                            states_to_annotate['Opened Stores per Capita'])
                        if state in state_centers],
                    mode='text',
                    showlegend=False,
                    textfont=dict(size=11, color="black"),
                    hoverinfo='skip'  # Disables hover for annotations
                )
                fig_opened_map.add_trace(annotations_opened)

                # Display the map in Streamlit with full container width
                if column:
                    with column:
                        # Add end month to title for Active page
                        end_date_str = data['Period'].max().strftime('%B %Y')
                        title_suffix = f" ({end_date_str})" if store_type == "Active" else ""
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores per Capita by State (per Million){title_suffix}</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_map, use_container_width=True)
                else:
                    # Add end month to title for Active page
                    end_date_str = data['Period'].max().strftime('%B %Y')
                    title_suffix = f" ({end_date_str})" if store_type == "Active" else ""
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores per Capita by State (per Million){title_suffix}</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_map, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating per capita map: {e}")
            else:
                st.write(f"Error creating per capita map: {e}")
                
                    'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT',
                    'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV',
                    'Wisconsin': 'WI', 'Wyoming': 'WY', 'Puerto Rico': 'PR'
                }

                # Create reverse dictionary to convert abbreviations to full names
                abbreviation_to_full = {v: k for k, v in state_abbreviations.items()}

                # Function to map full state names to abbreviations
                def map_state_names(df, state_col='State'):
                    df[state_col] = df[state_col].map(lambda x: state_abbreviations.get(x, x))
                    return df

                # Apply the mapping
                mapped_data = map_state_names(data.copy())
                mapped_opened_by_state = map_state_names(opened_by_state.copy())

                # Create the choropleth map
                fig_opened_map = px.choropleth(
                    mapped_opened_by_state,
                    locations="State",
                    locationmode="USA-states",
                    color="Opened Stores per Capita",
                    color_continuous_scale=["#ffffff", color],
                    scope="usa",
                    hover_name="State",
                    hover_data={"State": False}  # Only show what we specify in hovertemplate
                )

                # Calculate metadata for each state
                state_metadata = {}
                for state in mapped_opened_by_state['State']:
                    state_data = mapped_data[mapped_data['State'] == state]
                    state_metadata[state] = {
                        'num_sectors': state_data['Sector_Coresight'].nunique() if 'Sector_Coresight' in state_data.columns else 0,
                        'num_banners': state_data['ChainName_Coresight'].nunique() if 'ChainName_Coresight' in state_data.columns else 0,
                        'num_msa': state_data['MsaName'].nunique() if 'MsaName' in state_data.columns else 0
                    }

                # Calculate overall date range
                start_date = mapped_data['Period'].min()
                end_date = mapped_data['Period'].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str   = end_date.strftime("%b %Y")

                date_period = f"{start_date_str} to {end_date_str}"

                # Customize hover template with state-specific metadata
                fig_opened_map.update_traces(
                    hovertemplate=(
                        "<b>%{hovertext}</b><br>"  # State name
                        f"<span style='color:{color}'>●</span> "
                        "<b>Stores per Million:</b> %{z:,.2f}<br><br>"  # Per capita value
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Date Period: {date_period}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of Sectors: %{customdata[0]:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of Banners: %{customdata[1]:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        "<span style='color:black'>Number of MSA: %{customdata[2]:,}</span><br>"
                        "<extra></extra>"
                    ),
                    customdata=[[state_metadata[state]['num_sectors'], state_metadata[state]['num_banners'], state_metadata[state]['num_msa']] for state in mapped_opened_by_state['State']],
                    hoverlabel=dict(
                        bgcolor="white",
                        bordercolor=color,
                        font=dict(size=13, color="black", family="Arial")
                    )
                )

                fig_opened_map.update_coloraxes(
                    colorbar_title=f"{store_type} Stores per Million Capita"
                )

                # Customize layout
                fig_opened_map.update_layout(
                    margin=dict(l=0, r=0, t=0, b=0),
                    geo=dict(
                        projection_scale=1.2,
                        center=dict(lat=37.5, lon=-95),
                        showlakes=True,
                        lakecolor='rgb(255, 255, 255)',
                        showframe=False,
                        showcoastlines=False
                    )
                )

                # Approximate center coordinates for each state
                state_centers = {
                    'AL': (-86.7, 32.7), 'AK': (-152.4, 64.2), 'AZ': (-111.9, 34.3), 'AR': (-92.4, 34.8),
                    'CA': (-119.4, 37.3), 'CO': (-105.5, 39.0), 'CT': (-72.7, 41.6), 'DE': (-75.5, 39.0),
                    'DC': (-77.0, 38.9), 'FL': (-82.5, 27.8), 'GA': (-83.4, 32.6), 'HI': (-157.5, 20.9),
                    'ID': (-114.4, 44.2), 'IL': (-89.4, 40.0), 'IN': (-86.2, 40.3), 'IA': (-93.5, 42.1),
                    'KS': (-98.3, 38.5), 'KY': (-85.0, 37.5), 'LA': (-91.1, 30.9), 'ME': (-69.4, 45.3),
                    'MD': (-76.6, 39.0), 'MA': (-71.8, 42.3), 'MI': (-84.5, 44.2), 'MN': (-94.3, 46.3),
                    'MS': (-89.7, 32.7), 'MO': (-92.6, 38.5), 'MT': (-110.0, 46.9), 'NE': (-99.9, 41.5),
                    'NV': (-116.6, 39.3), 'NH': (-71.6, 43.7), 'NJ': (-74.4, 40.1), 'NM': (-106.0, 34.5),
                    'NY': (-75.5, 43.0), 'NC': (-79.0, 35.6), 'ND': (-100.5, 47.6), 'OH': (-82.8, 40.4),
                    'OK': (-97.5, 35.5), 'OR': (-120.6, 43.8), 'PA': (-77.2, 40.9), 'RI': (-71.5, 41.7),
                    'SC': (-80.9, 33.9), 'SD': (-100.4, 44.4), 'TN': (-86.6, 35.7), 'TX': (-99.9, 31.5),
                    'UT': (-111.6, 39.3), 'VT': (-72.7, 44.0), 'VA': (-78.9, 37.8), 'WA': (-120.7, 47.5),
                    'WV': (-80.6, 38.5), 'WI': (-89.9, 44.5), 'WY': (-107.6, 43.1), 'PR': (-66.5, 18.2)
                }

                # State annotations (with hover disabled)
                excluded_states = detect_overlapping_states(mapped_opened_by_state, state_centers)
                states_to_annotate = mapped_opened_by_state[~mapped_opened_by_state['State'].isin(list(excluded_states))]

                # Add Scattergeo layer for non-overlapping state annotations only
                annotations_opened = go.Scattergeo(
                    locationmode='USA-states',
                    lon=[state_centers[state][0] for state in states_to_annotate['State'] if state in state_centers],
                    lat=[state_centers[state][1] for state in states_to_annotate['State'] if state in state_centers],
                    text=[f"{state}<br>{opened_per_capita:,.2f}"
                        for state, opened_per_capita in zip(states_to_annotate['State'], 
                                                            states_to_annotate['Opened Stores per Capita'])
                        if state in state_centers],
                    mode='text',
                    showlegend=False,
                    textfont=dict(size=11, color="black"),
                    hoverinfo='skip'  # Disables hover for annotations
                )
                fig_opened_map.add_trace(annotations_opened)

                # Display the map in Streamlit with full container width
                if column:
                    with column:
                        # Add end month to title for Active page
                        end_date_str = data['Period'].max().strftime('%B %Y')
                        title_suffix = f" ({end_date_str})" if store_type == "Active" else ""
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores per Capita by State (per Million){title_suffix}</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_map, use_container_width=True)
                else:
                    # Add end month to title for Active page
                    end_date_str = data['Period'].max().strftime('%B %Y')
                    title_suffix = f" ({end_date_str})" if store_type == "Active" else ""
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>{store_type} Stores per Capita by State (per Million){title_suffix}</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_map, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating per capita map: {e}")
            else:
                st.write(f"Error creating per capita map: {e}")
                
    @staticmethod
    def render_opened_sectors_bar_chart(data, column=None, store_type="Opened", color="#A3C0CE"):
        """Render the opened sectors bar chart"""
        try:
            opened_store_counts = data['Sector_Coresight'].value_counts().head(15).dropna()
            if opened_store_counts.empty:
                if column:
                    with column:
                        st.markdown(
                            "<h4 style='font-size: 20px;text-align: center; top-align: center; color: red;'>By Sector data not available</h4>",
                            unsafe_allow_html=True
                        )
                else:
                    st.markdown(
                        "<h4 style='font-size: 20px;text-align: center; top-align: center; color: red;'>By Sector data not available</h4>",
                        unsafe_allow_html=True
                    )
            else:
                y_max_opened = UIComponents.calculate_yaxis_limit(opened_store_counts.max())

                # Calculate dynamic date period
                start_date = data['Period'].min()
                end_date = data['Period'].max()
                start_date_str = start_date.strftime("%b %Y")
                end_date_str   = end_date.strftime("%b %Y")

                date_period = f"{start_date_str} to {end_date_str}"

                # Calculate metadata for the entire dataset
                num_banners = data['ChainName_Coresight'].nunique()
                num_states = data['State'].nunique()
                num_msa = data['MsaName'].nunique()

                # Create figure with consistent styling
                fig_opened_bar = go.Figure()

                fig_opened_bar.add_trace(go.Bar(
                    x=opened_store_counts.index,
                    y=opened_store_counts.values,
                    marker_color=color,
                    text=[f"{x:,}" for x in opened_store_counts.values],
                    textposition='outside',
                    hovertemplate=(
                        "<b>%{x}</b><br>"  # Sector name
                        f"<span style='color:{color}'>●</span> "
                        f"<b>{store_type} Stores:</b> %{{y:,}}<br><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Date Period: {date_period}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Number of Banners: {num_banners:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Number of States: {num_states:,}</span><br>"
                        f"<span style='color:{color}'>•</span> "
                        f"<span style='color:black'>Number of MSA: {num_msa:,}</span><br>"
                        "<extra></extra>"
                    ),
                    hoverlabel=dict(
                        bgcolor="white",
                        bordercolor=color,
                        font=dict(size=13, color="black", family="Arial")
                    )
                ))

                fig_opened_bar.update_layout(
                    xaxis_title="Sector",
                    yaxis_title=f"{store_type} Stores",
                    yaxis=dict(
                        range=[0, y_max_opened],
                        autorange=False,
                        showline=True,
                        zeroline=False
                    ),
                    xaxis=dict(
                        showline=True,
                        zeroline=False,
                        tickangle=45 if len(opened_store_counts) > 5 else 0  # Auto-rotate if many sectors
                    ),
                    height=400,
                    margin=dict(l=20, r=20, t=60, b=40),  # Increased bottom margin for rotated labels
                    uniformtext_minsize=8,
                    uniformtext_mode='hide'
                )

                # Additional label rotation for many sectors
                if len(opened_store_counts) > 8:
                    fig_opened_bar.update_layout(
                        xaxis=dict(tickangle=60),
                        margin=dict(b=60)  # Extra bottom margin
                    )

                # Bar Chart in 30% width column
                if column:
                    with column:
                        st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {opened_store_counts.shape[0]} Sectors</h4>", unsafe_allow_html=True)
                        st.plotly_chart(fig_opened_bar, use_container_width=True)
                else:
                    st.markdown(f"<h4 style='font-size: 20px;text-align: center;'>Top {opened_store_counts.shape[0]} Sectors</h4>", unsafe_allow_html=True)
                    st.plotly_chart(fig_opened_bar, use_container_width=True)
        except Exception as e:
            if column:
                with column:
                    st.write(f"Error creating sectors chart: {e}")
            else:
                st.write(f"Error creating sectors chart: {e}")